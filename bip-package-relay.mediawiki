<pre>
  BIP: ?
  Layer: Peer Services
  Title: Ancestor Package Relay
  Author: Gloria Zhao <gloriajzhao@gmail.com>
  Comments-Summary:
  Comments-URI:
  Status: Draft
  Type: Standards Track
  Created: 2022-08-08
  License: BSD-3-Clause
</pre>

==Abstract==

Peer-to-peer protocol message enabling nodes to request and relay the unconfirmed ancestor package
of a given transaction. Enable nodes to request and relay multiple transactions in batches.

==Motivation==

(1) Help incentive-compatible transactions propagate.

Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate
the incentive compatibility of transactions in the mempool (PR #7594) and selecting them for
inclusion in blocks (PR #7600). Incentive-compatible mempool and miner policies help create a fair,
fee-based market for block space. While miners maximize transaction fees in order to earn higher
block rewards, non-mining users participating in transaction relay reap many benefits from employing
policies that result in a mempool with the same contents, including faster compact block relay and
more accurate fee estimation. Additionally, users may take advantage of mempool and miner policy to bump
the priority of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).

Only considering transactions one at a time for submission to the mempool creates a limitation in
the node's ability to determine which transactions have the highest feerates, since it cannot take
into account descendants until all the transactions are in the mempool. Similarly, it cannot use a
transaction's descendants when considering which of two conflicting transactions to keep (Replace by
Fee or RBF).

When a user's transaction does not meet a mempool's minimum feerate and they cannot create a
replacement transaction directly, their transaction will simply be rejected by this mempool. They
also cannot attach a descendant to pay for replacing a conflicting transaction.

This limitation harms users' ability to fee-bump their transactions. Further, it presents a security
issue in contracting protocols which rely on presigned, time-sensitive transactions to prevent
cheating (HTLC-Timeout in LN Penalty, Unvault Cancel in Revault [6], Refund Transaction in Discreet
Log Contracts [7], Update in eltoo[8][9]). In other words, a key security assumption of many
contracting protocols is that all parties can propagate and confirm transactions in a timely manner.
Increasing attention has been brought to "pinning attacks," a type of censorship in which the
attacker uses mempool policy restrictions to prevent a transaction from being relayed or getting
mined. [0][1][2][3]

These transactions must meet a certain confirmation target to be effective, but their feerates
are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no
fee-bumping options are available, attackers can steal money from their counterparties.  Always
overestimating fees may sidestep this issue temporarily (while mempool traffic is low and
predictable), but this solution is not foolproof and wastes users' money. For some attacks,
the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,
which is an unreasonable security requirement.

The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or
more low-fee parent transactions with a high-fee child, instead of separately. A package-aware
mempool policy can help determine if it would actually be economically rational to accept a
transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption
of these policies would create a more purely-feerate-based market for block space and allow
contracting protocols to adjust fees (and therefore mining priority) at broadcast time.

Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is
sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying
combinations of transactions rejected from their mempools), but this practice would likely be
inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal
suggests adding new p2p messages enabling nodes to request and share package validation-related
information with one another, resulting in a more efficient and reliable way to propagate packages.

(2) Eliminate txid-based transaction relay and make orphan handling more robust.

Txid-based transaction relay is problematic since a transaction's witness may be malleated without
changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded
or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't
ever need to use txid-based transaction relay.

A single use case of txid-based relay remains: handling "orphans," or transactions spending
output(s) from a transaction they are unaware of.  Orphans are common for new nodes that have just
completed Initial Block Download (IBD) and do not have an up-to-date mempool.

Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid
(inputs specify by txid, not wtxid). These parents may end up being orphans as well, if they also
spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic
for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p
network and txid-based relay between two wtxid-relay peers.

This proposal makes orphan-fetching more efficient and no longer require txid-based relay.

==Definitions==

Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of
Tx1 and Tx1 is a '''child''' of Tx0.

A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.
A transaction's '''descendants''' include, recursively, its children, the children of its children,
etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.

A '''package''' is an ordered list of transactions, representable by a connected Directed Acyclic
Graph (a directed edge exists between a transaction that spends the output of another transaction).

An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed
ancestors.

==Specification==

===Intended Protocol Flow===

Upon encountering an orphan, a receiver may request package information delineating all of the
ancestors and then request the missing ones. This is done without using txid-based relay.

[[File:./bip-package-relay/protocol_flow.png|1200px]]

This also means that too-low-feerate transactions (i.e. below the node's minimum mempool feerate)
with high-feerate descendants are propagated as packages when nodes are using BIP133 fee filters.
Since the low-feerate transaction is below the node's fee filer, the sender will not announce it.
The high-feerate transaction is seen and handled as an orphan, the transactions are validated as a
package, and so the protocol naturally works for this use case.

[[File:./bip-package-relay/package_cpfp_flow.png|1200px]]

''Diagram: Legacy vs. ancestors package relay orphan fetching.''

Ancestor package relay is negotiated between two peers during the version handshake using a
"sendpackages" message containing version=1. It requires both peers to support wtxid-based relay
because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions
of packages should send multiple "sendpackages" messages.

[[File:./bip-package-relay/version_negotiation.png|1200px]]

''Diagram: Negotiation of multiple version of package relay between peers.''

===New Messages===

Four new protocol messages and a getdata type MSG_ANCPKGINFO are added.

====sendpackages====

{|
|  Field Name  ||  Type  ||  Size  ||  Purpose
|-
|version || uint32_t || 4 || Denotes a package version supported by the node.
|-
|}

# The "sendpackages" message has the structure defined above, with pchCommand == "sendpackages".

# During version handshake, nodes should send a "sendpackages" message indicate they support package relay and may request packages. Nodes should send a "sendpackages" message for each version they support.

# Upon receipt of a "sendpackages" message with a version that is not supported, a node must treat the peer as if it never received the message.

# The "sendpackages" message MUST be sent before sending a "verack" message. If a "sendpackages" message is received afer "verack", the sender may be disconnected.

# A node that sent fRelay=false in their "version" message MUST NOT send a "sendpackages" message.

# A node that sends "sendpackages" MUST also send "wtxidrelay". Upon receipt of a "verack", if the sender has sent a "sendpackages" but not "wtxidrelay", the sender may be disconnected.

====getpkgtxns====

{|
|  Field Name  ||  Type  ||  Size  ||   Purpose
|-
|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.
|-
|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.
|}

# The "getpkgtxns" message has the structure defined above, with pchCommand == "getpkgtxns".

# A "getpkgtxns" message should be used to request all or some of the transactions previously announced in a "ancpkginfo" message, specified by witness transactiosome id. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated immediately.

# Upon receipt of a "getpkgtxns" message, a node must respond with either a "pkgtxns" containing the requested transactions or a "notfound" message indicating one or more of the transactions is unavailable.

====pkgtxns====

{|
|  Field Name  ||  Type  ||  Size  ||   Purpose
|-
|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.
|-
|txns||List of transactions||variable|| The transactions in the package.
|}

# The "pkgtxns" message has the structure defined above, with pchCommand == "pkgtxns".

# A "pkgtxns" message should contain the transaction data requested using "getpkgtxns".

# Upon reeipt of a "pkgtxns" message, the node should validate the transactions together as a package rather than individually.

# A "pkgtxns" message should only be sent to a peer that requested the package using "getpkgtxns".  If a node receives an unsolicited package, the sender may be disconnected.


====ancpkginfo====
{|
|  Field Name  ||  Type  ||  Size  ||   Purpose
|-
|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.
|-
|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.
|}

# The "ancpkginfo" message has the structure defined above, with pchCommand == "ancpkginfo".

# The "txns" field should contain a list of wtxids which constitute the ancestor package of the last wtxid (the "representative transaction"). Apart from the last wtxid, the rest of the wtxids may be in any order.

# Upon receipt of a "ancpkginfo" message, the node may use it to request the transactions not already in its mempool.

# Upon receipt of a malformed "ancpkginfo" message that does not contain the ancestor package of the transaction (which the node learns after receiving the transaction data and validating them), the sender may be disconnected.

# A node MUST NOT send a "ancpkginfo" message that has not been requested by the recipient. Upon receipt of an unsolicited "ancpkginfo", a node should disconnect the sender.

# A "ancpkginfo" message should only be sent if both peers agreed to send ancestor packages in the version handshake. If a "ancpkginfo" message is received from a peer with which ancestor package relay was not negotiated, the sender should be disconnected.

====MSG_ANCPKGINFO====

# A new inv type (MSG_ANCPKGINFO == 0x6) is added, for use only in getdata requests pertaining to ancestor packages.

# As a getdata request type, it indicates that the sender wants a "ancpkginfo" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.

# Upon receipt of a "getdata(MSG_ANCPKGINFO)" request for, the node should respond with the "ancpkginfo" corresponding to the transaction's unconfirmed ancestor package, or with NOTFOUND.  The wtxid of the requested transaction should be the last item in the list. The node should not assume that the sender is requesting the transaction data as well.

# The inv type should not be used in announcements, i.e. "inv(MSG_ANCPKGINFO)" should never be sent. This type of package relay has previously been referred to as "receiver-initiated package relay."

==Compatibility==

Older clients remain fully compatible and interoperable after this change. Clients implementing this
protocol will only attempt to send and request packages if agreed upon during the version handshake.

If a node supports package relay, it may accept low-feerate transactions (e.g. paying zero fees)
into its mempool, but non-package relay nodes would most likely reject them. In the interest of not
wasting bandwidth, a package relay node should probably not announce descendants of below-fee-filter
transactions to non-package relay peers.

===Package Erlay===

A client using BIP330 reconciliation-based transaction relay (Erlay) is able to use package relay
without interference. After reconciliation, any transactions with unconfirmed ancestors may be
relayed using ancestor package relay.

==Rationale==

===P2P Message Design===

Several alternative designs were considered. One should measure alternative solutions based on the
resources used to communicate (not necessarily trustworthy) information: We would like to minimize
network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions
that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.

Consider these scenarios specifically transaction relay:

Alice (the "sender") is relaying transactions to Bob (the "receiver").
Alice's mempool has a minimum feerate of 1sat/vB and Bob's has a minimum feerate of 3sat/vB.
For simplicity, all transactions are 1600Wu in virtual size and 500 bytes in serialized size.
Apart from the spending relationships specified, all other inputs are from confirmed UTXOs.

# Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.

# Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.

# Package {E, F, G, H, J} that pays 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.

[[File:./bip-package-relay/tx_scenarios.png|800px]]

''Diagram: Transaction scenarios to consider when evaluating alternative designs. Note that the average transaction size is much larger than a SHA256 hash.''

'''Package Information Only:''' Just having "ancpkginfo" gives enough information for the receiver to
accept the package. Omit the "getpkgtxns" and "pkgtxns" messages. While this option is a good
fallback if batched transaction download fails for some reason, it shouldn't be used as the default
because it always requires storage of unvalidated transactions.

[[File:./bip-package-relay/package_info_only.png|1200px]]

''Diagram: Alternative design where package relay only involves information.''

'''No Package Information Round:''' Instead of having a package information round, just use the
child's wtxid to refer to the package and always send the entire package together. This would cause
nodes to redownload duplicate transactions.

[[File:./bip-package-relay/no_package_info.png|900px]]

''Diagram: Alternative design where nodes relay package transactions directly.''

===Versioning System===

Attempting to support arbitrary packages in mempool validation may result in very complex logic, new
Denial of Service attack vectors, and policy limitations that could be leveraged to censor
transactions (aka "pinning attacks"). However, the p2p protocol should be extensible to support
multiple types of packages based on future desired use cases. It should also be possible to support
some subset of the existing package types. For example, if a node's mempool policy doesn't support
or a node implementation deprecates version 2, it should be easy to announce support for version 1,
but not version 2, packages.

===Sender vs Receiver-Initiated===

Receiver-intiated package relay enables a node to resolve orphans efficiently, without requesting by
txid, and always end up with the incentive-compatible transactions in their mempool. Of course, it's
built with bandwidth-conscious logic such as ensuring nodes never download a transaction more than
once. Sender-initiated package relay should, theoretically, save a round trip by notifying the
receiver ahead of time that "hey, this is going to be a package, so make sure you download and
submit these transactions together." As with any proactive communication, there is a chance that the
node already knows this information, so this network bandwidth was wasted.

The logic used to decide *when* to announce a package proactively determines whether it is a net
increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save
bandwidth without any idea of what its bandwidth usage actually looks like in practice. A
sender-initiated protocol should be designed carefully, informed by data collected from the mainnet
p2p network. However, there is no historical transaction data to use because the goal is to enable
currently-rejected transactions to propagate. In order to get this right, it is best to hold off on
sender-initiated for now, deploy receiver-initiated package relay, observe its usage and figure out
where we can save a round trip, and then introduce a well-researched sender-initiated package relay
protocol.

===Package Mempool Acceptance Policy===

FIXME: Add summary of the package mempool acceptance policy that enables CPFP in packages. The crux
of package relay is a mempool policy that works.

==Implementation==

Package mempool acceptance logic and policy: [https://github.com/bitcoin/bitcoin/pull/22290 PR#22290]

Package relay : WIP

==Copyright==

This document is placed in the public domain.

==Acknowledgements==

Thank you to Suhas Daftuar, John Newbery, Anthony Towns, and Martin Zumsande for input on the design.

Much of this work is inspired by ideas and code by Suhas Daftuar and Antoine Riard. [10][11][12][13]

Thank you to Matt Corallo, Christian Decker, David Harding, Antoine Poinsot, Antoine Riard, Gregory
Sanders, Chris Stewart, Bastien Teinturier, and others for input on the desired interface for
contracting protocols.

==References==

[0]: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html

[1]: https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html

[2]: https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html

[3]: https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md

[4]: https://gist.github.com/glozow/d362100715e9a3e2e61cb4b600663377

[5]: https://github.com/bitcoin/bitcoin/pull/22674#issuecomment-897951289

[6]: https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx

[7]: https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction

[8]: https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1

[9]: https://gist.github.com/instagibbs/b3095752d6289ab52166c04df55c1c19

[10]: https://gist.github.com/sdaftuar/8756699bfcad4d3806ba9f3396d4e66a

[11]: https://github.com/bitcoin/bitcoin/issues/14895

[12]: https://github.com/bitcoin/bitcoin/pull/16401

[13]: https://github.com/bitcoin/bitcoin/pull/19621
