<pre>
  BIP: ?
  Layer: Peer Services
  Title: Child-With-Parents (v1) Packages
  Author: Gloria Zhao <gloriajzhao@gmail.com>
  Comments-Summary:
  Comments-URI:
  Status: Draft
  Type: Standards Track
  Created: 2022-04-14
  License: PD
</pre>

==Abstract==

Extend package relay for packages consisting of one transaction and some unconfirmed parents.
Enable the use case in which a child pays for its otherwise-too-low-fee parent(s) and their mempool
conflict(s).

==Motivation==

Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate
the incentive compatibility of transactions in the mempool (PR #7594) and selecting them for
inclusion in blocks (PR #7600). Incentive-compatible mempool and miner policies help create a fair,
fee-based market for block space. While miners maximize transaction fees in order to earn higher
block rewards, non-mining users participating in transaction relay reap many benefits from employing
policies that result in a mempool with the same contents, including faster compact block relay and
more accurate fee estimation. Additionally, users may take advantage of mempool and miner policy to bump
the priority of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).

Only considering transactions one at a time for submission to the mempool creates a limitation in
the node's ability to determine which transactions have the highest feerates, since it cannot take
into account descendants until all the transactions are in the mempool. Similarly, it cannot use a
transaction's descendants when considering which of two conflicting transactions to keep (Replace by
Fee or RBF).

When a user's transaction does not meet a mempool's minimum feerate and they cannot create a
replacement transaction directly, their transaction will simply be rejected by this mempool. They
also cannot attach a descendant to pay for replacing a conflicting transaction.

This limitation harms users' ability to fee-bump their transactions. Further, it presents a security
issue in contracting protocols which rely on presigned, time-sensitive transactions to prevent
cheating (HTLC-Timeout in LN Penalty, Unvault Cancel in Revault [6], Refund Transaction in Discreet
Log Contracts [7], Update in eltoo[8][9]). In other words, a key security assumption of many
contracting protocols is that all parties can propagate and confirm transactions in a timely manner.
Increasing attention has been brought to "pinning attacks," a type of censorship in which the
attacker uses mempool policy restrictions to prevent a transaction from being relayed or getting
mined. [0][1][2][3]

These transactions must meet a certain confirmation target to be effective, but their feerates
are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no
fee-bumping options are available, attackers can steal money from their counterparties.  Always
overestimating fees may sidestep this issue temporarily (while mempool traffic is low and
predictable), but this solution is not foolproof and wastes users' money. For some attacks,
the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,
which is an unreasonable security requirement.

The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or
more low-fee parent transactions with a high-fee child, instead of separately. A package-aware
mempool policy can help determine if it would actually be economically rational to accept a
transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption
of these policies would create a more purely-feerate-based market for block space and allow
contracting protocols to adjust fees (and therefore mining priority) at broadcast time.

Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is
sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying
combinations of transactions rejected from their mempools), but this practice would likely be
inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal
suggests adding new p2p messages enabling nodes to request and share package validation-related
information with one another, resulting in a more efficient and reliable way to propagate packages.

==Definitions==

Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of
Tx1 and Tx1 is a '''child''' of Tx0.

A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.
A transaction's '''descendants''' include, recursively, its children, the children of its children,
etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.

A '''package''' is an ordered list of transactions, representable by a connected Directed Acyclic
Graph (a directed edge exists between a transaction that spends the output of another transaction).

==Specification==

===Intended Protocol Flow===

When relaying a package of low-fee parent(s) and high-fee child, the sender and receiver do the
following:

# Sender announces they have a child-with-parents package for a child that pays for otherwise-too-low-fee parent(s) using "inv(MSG_PKG1)".

# The receiver requests package information using "getdata(MSG_PKG1)".

# The sender provides package information using "pkginfo1", listing the wtxids of the transactions in the package.

# The receiver uses the package information to decide how to request the transactions. For example, if the receiver already has some of the transactions in their mempool, they should only request the missing ones.

# Upon receiving a "pkgtxns", the receiver submits the transactions together as a package.

[[File:./bip-v1-packages/normal_child_parents.png|600px]]

''Diagram: The intended protocol flow for a sender relaying zero-fee parents with a high-fee child.''

Child-with-parents package relay is negotiated between two peers through the
"sendpackages" message with version=1. Nodes should only announce support for version 1 package
relay if their mempool policy supports acceptance of such packages. For example, if a mempool is
configured to reject transactions with more than 3 ancestors, not all version 1 packages will be
supported. See [rules](#Child-With-Parents-Packages) on version 1 packages.

[[File:./bip-v1-packages/sendpackages_negotiation.png|600px]]

''Diagram: Version 1 package relay is negotiated during the version handshake.''

===New Messages===

A new inv type, "MSG_PKG1", and new protocol message, "PKGINFO1", are added.

====pkginfo1====

{|
|  Field Name  ||  Type  ||  Size  ||   Purpose
|-
|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.
|-
|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.
|}


# The "pkginfo1" message has the structure defined above, with pchCommand == "pkginfo1".

# A "pkginfo1" message contains information about a version 1 package (defined below).

# Upon receipt of a malformed "pkginfo1" message or package that does not abide by the rules specified, the sender may be disconnected.

# A node MUST NOT send a "pkginfo1" message that has not been requested by the recipient using "getdata(MSG_PKG1)". Upon receipt of an unsolicited "pkginfo1", a node may disconnect the sender.

# A "pkginfo1" message should only be sent if both peers agreed to send version 1 packages in the version handshake. If a "pkginfo1" message is received from a peer with which package relay was not negotiated, the sender may be disconnected.

====MSG_PKG1====

# A new inv type (MSG_PKG1 == 0x6) is added, for use in inv messages and getdata requests pertaining to version 1 packages.

# As an inv type, it indicates that both transaction data and version 1 package information are available for the transaction. The transaction is referenced by its wtxid. As a getdata request type, it indicates that the sender wants package information for the transaction.

# Nodes may request package information using "getdata(MSG_PKG1)" even if it was not announced using "inv(MSG_PKG1)".

# Upon receipt of a "getdata" request for "MSG_PKG1", the node should respond with the version 1 package corresponding to the requested transaction or with NOTFOUND. The node should not assume that the sender is requesting the transaction data as well.

===Child With Parents Packages===

Version 1 package relay supports child-with-parents packages. All v1 packages sent between nodes
MUST abide by the rules below, otherwise the package is malformed and the sender may be
disconnected.

A version 1 or '''child-with-parents''' package can be defined for any transaction that spends an
unconfirmed input. The child can be thought of as the "representative" of the package, and so these
packages are announced using `MSG_PKG1(wtxid)` with the wtxid of that transaction.

A '''child-with-parents''' package MUST be:

# '''Child is the last transaction''' The child must be the last transaction in the package.

# '''Only 1 child with parents.''' Apart from the child, all other transactions must be direct parents. The package must consist of one transaction and at least one of its unconfirmed parents. There must not be any other transactions in the package. Other dependency relationships may exist within the package (e.g. one parent may spend the output of another parent) provided that topological order is respected.

# '''No conflicts.''' None of the transactions in the package may conflict with each other (i.e. spend the same prevout).

# '''Maximum count and size.''' The number of transactions does not exceed 25. The total weight (as defined by BIP141) of the transactions does not exceed 404000 Wu.

===Clarifications===

'''Q: What if the transaction has other parents or ancestors? What if its parents are high feerate?''

Not all of the child's parents must be present.

The child's unconfirmed ancestors must not be present unless they are direct parents of the child.

While a child-with-parents package is perhaps most relevant when the child has a higher feerate than
its parents, this property is not required to construct a valid package.

'''Q: Under what circumstances should a sender announce a child-with-parents package (send "inv(MSG_PKG1)")?'''

A child-with-parents package should be announced when all of the following conditions are met:

- The child's individual feerate is above the peer's fee filter and has one or more parents whose
  feerates are below the peer's fee filter.

- One or more of the transaction's parents does not meet the peer's fee filter and has not already
  been announced to this peer.

- The aggregate feerate of the constructed package is above the peer's fee filter.

This logic would be applied when the node is considering the announcement of the child. The parents
that don't meet the peer's fee filter would not be announced individually (since a BIP 133 fee
filter is being applied). The parents that do the peer's fee filter should still be announced
individually.

'''Q: Under what circumstances should a receiver request a child-with-parents package (send "getdata(MSG_PKG1)")?'''

Since the announcement does not commit to all of the transactions in the package, the receiver
should always request the package if the child (i.e. the hash specified in the inv message) is not
already present in their mempool.

It is common practice to reject a transaction (identified by its wtxid) if it was already validated
and rejected, unless a new block has been received since its rejection (the cache is cleared every
block, since a nonfinal/premature transaction can become valid after a new block is mined).

'''Q: What happens if the peers have different chain tips?'''

Peers may have different chain tips for various reasons (blocks take time to propagate across the
network, two competing blocks may be found at the same time, a block may arrive in between
announcement and download, etc.). This protocol doesn't guarantee that the package will relay no
matter what, but can make a "best effort."

Whether one peer is ahead or the peers are on different forks, the chain tip mismatch is relevant
when a subset of the package is confirmed in one chain tip, but unconfirmed in the other. For
example, if the receiver's chain tip is ahead of the sender's or a new block arrives between
"getpkgtxns" and "pkgtxns," some subset of the package may have confirmed (e.g. a parent which had
another child fee-bumping it) in the receiver's chain tip.

Currently, it is possible for a node to receive a transaction that has recently confirmed. It can
attempt to identify such a transaction when one or more of its inputs is unavailable and one or more
of its outputs is available in the node's UTXO set. The same heuristic should be used to remove
recently-confirmed transactions from a child-with-parents package. Doing so solves the cases in
which a node receives a package containing recently-confirmed transactions; it can "deduplicate"
those and still accept the remaining unconfirmed transactions.

On the other hand, if a package transaction is unconfirmed in the receiver's chain tip but confirmed
in the sender's chain tip, the package will contain orphans. The receiver should request a
tx-with-unconfirmed-ancestors package, i.e. send "getdata(MSG_PKG2, orphan_wtxid)."

==Compatibility==

Older clients remain fully compatible and interoperable after this change. Clients implementing this
protocol will only attempt to send and request packages if agreed upon during the version handshake.

If a node supports package relay, it may accept low-feerate transactions (e.g. paying zero fees)
into its mempool, but non-package relay nodes would most likely reject them. In the interest of not
wasting bandwidth, a package relay node should probably not announce descendants of below-fee-filter
transactions to non-package relay peers.

===Package Erlay===

A client using BIP330 reconciliation-based transaction relay (Erlay) is able to use package relay
without interference. In fact, a package of transactions may be announced using both Erlay and
package relay. After reconciliation, if the initiator would have announced a transaction by wtxid
but has relevant package information for it, they may send "inv(MSG_PKG1)" instead of "inv(WTX)".

[[File:./bip-v1-packages/package_erlay.png|900px]]

''Diagram: Transactions can be announced via both Erlay and package relay.''

==Rationale==

===Why Child With Parents?===

From surveys of developers, with heavy consideration towards LN, it was determined that a
two-generation, child-with-parents topology would provide the desired utility. Namely,
this allows for batched fee-bumping by CPFP. [4][5]

A child-with-parents package also has several properties that make many things easier to
reason about.

It's easy to verify whether a package is child-with-parents without access to mempool contents or
current chainstate.

Every transaction in the package is part of the child's ancestor set. This simplifies the
enforcement of mempool descendant and ancestor limits. It is easy for a node to decide when to
announce a package using the contents of its mempool.

Due to the two-generation restriction, reasoning about the incentive compatibility of a
child-with-parents package is relatively simple. A '''package feerate''' can be defined very simply
and used in place of individual transaction feerate as follows:

# Ensure that the package is child-with-parents.

# Remove any transactions in the package which are already in the mempool or have the same txid as another transaction in the mempool. Remove any transactions that may have confirmed recently.

# Attempt to submit each transaction with its in-package ancestor set (in a child-with-parents package, this is usually just each individual transaction). If any transactions are successfully added to the mempool, remove them from the package.

# The '''package feerate''' is the total fees divided by the total weight of all remaining transactions in the package.

# Use package feerate in place of individual feerate when enforcing feerate-related policies such as minimum relay feerate, dynamic mempool minimum feerate, and replace-by-fee rules.

[[File:./bip-v1-packages/dedup_still_too_low.png|600px]]

'''Warning:''' These two aggregate feerate assessments work with child-with-parents
packages specifically due to their topology. They may not be incentive compatible for packages of
other topologies.

==Implementation==

Package mempool acceptance logic and policy: [https://github.com/bitcoin/bitcoin/pull/22290 PR#22290]

Package relay : WIP

==Copyright==

This document is placed in the public domain.

==Acknowledgements==

Thank you to Suhas Daftuar, John Newbery, Anthony Towns, and Martin Zumsande for input on the design.

Thank you to Matt Corallo, Christian Decker, David Harding, Antoine Poinsot, Antoine Riard, Gregory
Sanders, Chris Stewart, Bastien Teinturier, and others for input on the desired interface for
contracting protocols.

==References==

[0]: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html

[1]: https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html

[2]: https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html

[3]: https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md

[4]: https://gist.github.com/glozow/d362100715e9a3e2e61cb4b600663377

[5]: https://github.com/bitcoin/bitcoin/pull/22674#issuecomment-897951289

[6]: https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx

[7]: https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction

[8]: https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1

[9]: https://gist.github.com/instagibbs/b3095752d6289ab52166c04df55c1c19
